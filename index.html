<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes, viewport-fit=cover">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="theme-color" content="#1a1a2e">
    <meta name="description" content="AI News Hub â€” curated AI news from multiple sources">
    <link rel="manifest" id="pwa-manifest">
    <title>AI News Hub</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:ital,opsz,wght@0,9..40,400;0,9..40,600;0,9..40,700;1,9..40,400&family=DM+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        :root {
            --ui-scale: 1;
            --bg: #0f0f1a;
            --bg-surface: #1a1a2e;
            --bg-elevated: #25253e;
            --text: #e8e8f0;
            --text-secondary: #9090b0;
            --accent: #7c6aef;
            --accent-glow: rgba(124, 106, 239, 0.25);
            --accent-bright: #9d8df7;
            --border: rgba(255,255,255,0.08);
            --border-hover: rgba(255,255,255,0.15);
            --success: #4ade80;
            --warning: #fbbf24;
            --error: #f87171;
            --font: 'DM Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            --mono: 'DM Mono', 'SF Mono', monospace;
            --radius: 10px;
            --shadow: 0 4px 24px rgba(0,0,0,0.4);
        }

        /* E-ink theme */
        html.eink {
            --bg: #ffffff; --bg-surface: #ffffff; --bg-elevated: #f5f5f5;
            --text: #111111; --text-secondary: #444444;
            --accent: #333333; --accent-glow: rgba(0,0,0,0.06); --accent-bright: #000000;
            --border: #cccccc; --border-hover: #999999;
            --success: #333; --warning: #333; --error: #333; --shadow: none;
        }
        html.eink * {
            transition: none !important; animation: none !important;
            box-shadow: none !important; text-shadow: none !important;
            backdrop-filter: none !important; -webkit-backdrop-filter: none !important;
        }
        html.eink body { background: #fff; }
        html.eink .news-item { border: 1px solid #bbb; border-left: 3px solid #333; }
        html.eink .news-item:hover { transform: none; }
        html.eink header { background: #fff; border-bottom: 2px solid #111; }
        html.eink .logo { color: #111; }
        html.eink .btn, html.eink .settings-btn { background: #fff; color: #111; border: 1px solid #888; }
        html.eink .time-filter-container select { background: #fff; color: #111; border: 1px solid #888; }
        html.eink .tabs { background: #fff; border: 1px solid #bbb; }
        html.eink .tab { color: #444; }
        html.eink .tab.active { background: #111; color: #fff; }
        html.eink .source-badge { filter: grayscale(1); }
        html.eink .stats-bar { background: #fff; border: 1px solid #bbb; }
        html.eink .stat-value { color: #111; }
        html.eink .more-btn { background: #111; color: #fff; border-radius: 0; }
        html.eink .install-prompt { background: #eee; color: #111; border: 1px solid #bbb; }
        html.eink .modal-content { border: 2px solid #111; }
        html.eink .modal-header { background: #eee; color: #111; }
        html.eink .save-btn { background: #111; border-radius: 0; }
        html.eink .comments-toggle { background: #f5f5f5; border: 1px solid #aaa; color: #111; }
        html.eink .comment-author { color: #111; }
        html.eink .comment-nested { border-left-color: #bbb; }

        /* Midnight â€” Apple Health inspired */
        html.midnight {
            --bg: #000000; --bg-surface: #1c1c1e; --bg-elevated: #2c2c2e;
            --text: #f5f5f7; --text-secondary: #8e8e93;
            --accent: #0a84ff; --accent-glow: rgba(10, 132, 255, 0.15); --accent-bright: #64d2ff;
            --border: rgba(255,255,255,0.08); --border-hover: rgba(255,255,255,0.16);
            --success: #30d158; --warning: #ffd60a; --error: #ff453a;
            --font: -apple-system, 'SF Pro Display', BlinkMacSystemFont, 'Segoe UI', sans-serif;
            --mono: 'SF Mono', 'Menlo', monospace;
            --radius: 13px;
            --shadow: 0 2px 12px rgba(0,0,0,0.6);
        }
        html.midnight body { background: #000; }
        html.midnight header { background: rgba(0,0,0,0.85); backdrop-filter: saturate(180%) blur(20px); -webkit-backdrop-filter: saturate(180%) blur(20px); border-bottom: 1px solid rgba(255,255,255,0.06); }
        html.midnight .logo { font-weight: 600; letter-spacing: -0.5px; }
        html.midnight .logo span { color: #0a84ff; }
        html.midnight .stats-bar { background: #1c1c1e; border: none; border-radius: 13px; }
        html.midnight .stat-value { color: #0a84ff; font-weight: 700; }
        html.midnight .stat-label { color: #8e8e93; font-size: calc(10px * var(--ui-scale)); letter-spacing: 1px; }
        html.midnight .tabs { background: #1c1c1e; border: none; border-radius: 13px; padding: 4px; }
        html.midnight .tab { border-radius: 10px; font-weight: 500; font-size: calc(13px * var(--ui-scale)); padding: 8px 14px; }
        html.midnight .tab:hover { background: #2c2c2e; }
        html.midnight .tab.active { background: #0a84ff; color: #fff; }
        html.midnight .news-item { background: #1c1c1e; border: none; border-left: 3px solid transparent; border-radius: 13px; margin-bottom: 10px; }
        html.midnight .news-item:hover { border-left-color: #0a84ff; background: #222224; transform: none; }
        html.midnight .news-title { font-weight: 600; letter-spacing: -0.2px; }
        html.midnight .news-title:hover { color: #0a84ff; }
        html.midnight .badge-hackernews { background: #ff9f0a18; color: #ff9f0a; border: none; }
        html.midnight .badge-reddit { background: #ff453a18; color: #ff453a; border: none; }
        html.midnight .badge-arxiv { background: #bf5af218; color: #bf5af2; border: none; }
        html.midnight .badge-github { background: #30d15818; color: #30d158; border: none; }
        html.midnight .badge-rss { background: #ff9f0a18; color: #ff9f0a; border: none; }
        html.midnight .badge-mastodon { background: #64d2ff18; color: #64d2ff; border: none; }
        html.midnight .ai-score { color: #30d158; }
        html.midnight .btn, html.midnight .settings-btn { background: #2c2c2e; border: none; color: #f5f5f7; border-radius: 10px; }
        html.midnight .btn:hover, html.midnight .settings-btn:hover { background: #3a3a3c; }

        .font-btn{
            background: var(--bg-elevated); border: 1px solid var(--border); color: var(--text);
            cursor: pointer; padding: 6px 10px; border-radius: var(--radius); transition: all 0.2s;
            display: inline-flex; align-items: baseline; gap: 2px; min-width: 42px; justify-content: center;
        }
        .font-btn:hover{ border-color: var(--border-hover); }
        .font-btn .a-small{ font-size: calc(12px * var(--ui-scale)); opacity: 0.85; line-height: 1; }
        .font-btn .a-big{ font-size: calc(18px * var(--ui-scale)); font-weight: 700; line-height: 1; }
        html[data-font="0"] { --ui-scale: 1; }
html[data-font="1"] { --ui-scale: 1.125; }
html[data-font="2"] { --ui-scale: 1.25; }
html.midnight .time-filter-container select { background: #2c2c2e; border: none; color: #f5f5f7; border-radius: 10px; }
        html.midnight .more-btn { background: #0a84ff; color: #fff; border: none; border-radius: 13px; font-weight: 600; }
        html.midnight .more-btn:hover { background: #0070e0; }
        html.midnight .install-prompt { background: #1c1c1e; border: none; border-radius: 13px; }
        html.midnight .modal-content { background: #1c1c1e; border: none; border-radius: 16px; }
        html.midnight .modal-header { background: #2c2c2e; border-radius: 16px 16px 0 0; }
        html.midnight .modal-body input[type="text"], html.midnight .modal-body select { background: #2c2c2e; border: none; color: #f5f5f7; border-radius: 10px; }
        html.midnight .save-btn { background: #0a84ff; border: none; border-radius: 13px; font-weight: 600; }
        html.midnight .save-btn:hover { background: #0070e0; }
        html.midnight .cmt-toggle { color: #0a84ff; }
        html.midnight .cmt-toggle:hover { background: rgba(10, 132, 255, 0.1); }
        html.midnight .comment { border-left-color: #3a3a3c; }
        html.midnight .cmt-author { color: #f5f5f7; }
        html.midnight .cmt-score { color: #ff453a; }
        html.midnight .comments-link { color: #0a84ff; }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: var(--font);
            background-color: var(--bg);
            color: var(--text);
            line-height: 1.6;
        }

        .container {
            max-width: 900px; margin: 0 auto; padding: 0 20px;
            padding-left: max(20px, env(safe-area-inset-left));
            padding-right: max(20px, env(safe-area-inset-right));
        }

        header {
            background: var(--bg-surface); border-bottom: 1px solid var(--border);
            padding: 14px 0; padding-top: max(14px, env(safe-area-inset-top));
            position: fixed; top: 0; width: 100%; z-index: 1000;
        }
        .header-content { display: flex; justify-content: space-between; align-items: center; gap: 12px; }
        .logo { font-size: calc(20px * var(--ui-scale)); font-weight: 700; color: var(--text); letter-spacing: -0.3px; }
        .logo span { color: var(--accent-bright); }
        .header-actions { display: flex; gap: 10px; align-items: center; }

        .time-filter-container select {
            background: var(--bg-elevated); color: var(--text); border: 1px solid var(--border);
            padding: 8px 30px 8px 12px; border-radius: var(--radius); font-size: calc(13px * var(--ui-scale));
            font-family: var(--font); cursor: pointer; appearance: none;
            background-image: url('data:image/svg+xml;charset=UTF-8,%3csvg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="%239090b0" stroke-width="2"%3e%3cpolyline points="6 9 12 15 18 9"%3e%3c/polyline%3e%3c/svg%3e');
            background-repeat: no-repeat; background-position: right 8px center; background-size: 14px;
        }
        .time-filter-container select option { background: var(--bg-surface); }

        .btn {
            background: var(--bg-elevated); color: var(--text); border: 1px solid var(--border);
            padding: 8px 14px; border-radius: var(--radius); cursor: pointer;
            font-size: calc(13px * var(--ui-scale)); font-family: var(--font); font-weight: 500; transition: all 0.2s;
        }
        .btn:hover { border-color: var(--border-hover); }

        .settings-btn {
            background: var(--bg-elevated); border: 1px solid var(--border); color: var(--text);
            cursor: pointer; font-size: calc(18px * var(--ui-scale)); padding: 6px 10px; border-radius: var(--radius); transition: all 0.2s;
        }
        .settings-btn:hover { border-color: var(--border-hover); }

        main {
            margin-top: calc(70px + env(safe-area-inset-top));
            min-height: calc(100vh - 70px);
            padding-top: 20px;
            padding-bottom: max(20px, env(safe-area-inset-bottom));
        }

        .install-prompt {
            background: var(--accent-glow); border: 1px solid var(--accent); color: var(--text);
            padding: 14px 18px; border-radius: var(--radius); margin-bottom: 20px;
            display: none; align-items: center; justify-content: space-between; gap: 12px; font-size: calc(14px * var(--ui-scale));
        }
        .install-prompt.show { display: flex; }

        .stats-bar {
            background: var(--bg-surface); border: 1px solid var(--border);
            padding: 16px 20px; border-radius: var(--radius); margin-bottom: 20px;
            display: flex; gap: 28px; flex-wrap: wrap;
        }

        .source-status {
            margin-top: -10px; margin-bottom: 18px;
            display: flex; flex-wrap: wrap; gap: 10px;
            font-size: calc(12px * var(--ui-scale)); color: var(--text-muted);
        }
        .source-status:empty { display: none; }
        .source-status .src-pill {
            padding: 4px 10px; border: 1px solid var(--border); border-radius: 999px;
            background: var(--bg-surface);
            white-space: nowrap;
        }

        .stat { display: flex; flex-direction: column; gap: 2px; }
        .stat-label { font-size: calc(11px * var(--ui-scale)); font-family: var(--mono); color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.8px; }
        .stat-value { font-size: calc(20px * var(--ui-scale)); font-weight: 700; color: var(--accent-bright); }

        .tabs {
            background: var(--bg-surface); border: 1px solid var(--border); border-radius: var(--radius);
            padding: 5px; margin-bottom: 20px; display: flex; gap: 4px;
            overflow-x: auto; -webkit-overflow-scrolling: touch; scrollbar-width: none;
        }
        .tabs::-webkit-scrollbar { display: none; }
        .tab {
            padding: 9px 16px; cursor: pointer; border: none; background: none;
            font-size: calc(13px * var(--ui-scale)); font-family: var(--font); color: var(--text-secondary);
            transition: all 0.2s; border-radius: 7px; font-weight: 500; white-space: nowrap; flex-shrink: 0;
        }
        .tab:hover { color: var(--text); background: var(--bg-elevated); }
        .tab.active { background: var(--accent); color: white; }

        .news-item {
            background: var(--bg-surface); border: 1px solid var(--border);
            padding: 18px 20px; margin-bottom: 12px; border-radius: var(--radius);
            transition: all 0.2s; border-left: 3px solid transparent;
        }
        .news-item:hover { border-left-color: var(--accent); border-color: var(--border-hover); transform: translateY(-1px); }

        .news-header { display: flex; justify-content: space-between; align-items: center; gap: 10px; margin-bottom: 8px; }
        .source-badge {
            padding: 3px 8px; border-radius: 4px; font-size: calc(10px * var(--ui-scale)); font-family: var(--mono);
            font-weight: 500; text-transform: uppercase; letter-spacing: 0.5px; white-space: nowrap;
        }
        .badge-hackernews { background: #ff660022; color: #ff9544; border: 1px solid #ff660033; }
        .badge-reddit { background: #ff450022; color: #ff7755; border: 1px solid #ff450033; }
        .badge-arxiv { background: #b31b1b22; color: #e85555; border: 1px solid #b31b1b33; }
        .badge-github { background: #ffffff11; color: #ccc; border: 1px solid #ffffff22; }
        .badge-rss { background: #ffa50022; color: #ffbb44; border: 1px solid #ffa50033; }
        .badge-mastodon { background: #6364ff22; color: #8888ff; border: 1px solid #6364ff33; }

        .news-title { font-size: calc(16px * var(--ui-scale)); font-weight: 600; color: var(--text); margin-bottom: 8px; text-decoration: none; display: block; line-height: 1.45; }
        .news-title:hover { color: var(--accent-bright); }
        .news-meta { font-size: calc(12px * var(--ui-scale)); font-family: var(--mono); color: var(--text-secondary); display: flex; flex-wrap: wrap; gap: 10px; align-items: center; }
        .comments-link { color: var(--accent-bright); text-decoration: none; font-size: calc(11px * var(--ui-scale)); }
        .comments-link:hover { text-decoration: underline; }
        .news-description { font-size: calc(14px * var(--ui-scale)); color: var(--text-secondary); line-height: 1.55; margin-top: 8px; max-height: 44px; overflow: hidden; }
        .ai-score { font-family: var(--mono); font-size: calc(10px * var(--ui-scale)); padding: 3px 7px; background: var(--accent-glow); border: 1px solid var(--accent); color: var(--accent-bright); border-radius: 4px; }

        /* Inline comments */
        .cmt-toggle {
            display: inline-flex; align-items: center; gap: 5px;
            padding: 3px 10px; background: var(--bg-elevated); border: 1px solid var(--border);
            border-radius: 5px; color: var(--accent-bright); font-size: calc(12px * var(--ui-scale)); font-family: var(--mono);
            cursor: pointer; transition: all 0.2s; min-height: 28px; line-height: 1;
        }
        .cmt-toggle:hover { border-color: var(--accent); background: var(--accent-glow); }
        .cmt-toggle.open { background: var(--accent-glow); border-color: var(--accent); }
        .cmt-toggle .arr { transition: transform 0.2s; display: inline-block; font-size: calc(10px * var(--ui-scale)); }
        .cmt-toggle.open .arr { transform: rotate(90deg); }

        .cmt-thread { margin-top: 12px; border-top: 1px solid var(--border); padding-top: 12px; display: none; }
        .cmt-thread.open { display: block; }
        .cmt-loading { padding: 12px; color: var(--text-secondary); font-size: calc(13px * var(--ui-scale)); font-style: italic; }
        .comment { padding: 10px 0; border-bottom: 1px solid var(--border); }
        .comment:last-child { border-bottom: none; }
        .comment-nest { margin-left: 16px; padding-left: 12px; border-left: 2px solid var(--border); }
        .cmt-author { font-family: var(--mono); font-size: calc(11px * var(--ui-scale)); font-weight: 600; color: var(--accent-bright); margin-bottom: 4px; }
        .cmt-author .cmt-time { font-weight: 400; color: var(--text-secondary); margin-left: 6px; }
        .cmt-author .cmt-score { font-weight: 400; color: var(--text-secondary); margin-left: 6px; }
        .cmt-body { font-size: calc(13px * var(--ui-scale)); line-height: 1.55; color: var(--text); word-break: break-word; }
        .cmt-body a { color: var(--accent-bright); }
        .cmt-body p { margin-bottom: 6px; }
        .cmt-body p:last-child { margin-bottom: 0; }
        .cmt-body pre, .cmt-body code { font-family: var(--mono); font-size: calc(12px * var(--ui-scale)); background: var(--bg); padding: 2px 5px; border-radius: 3px; }
        .cmt-body pre { padding: 8px 10px; overflow-x: auto; margin: 6px 0; }
        .cmt-body pre code { padding: 0; background: none; }

        .loading { text-align: center; padding: 60px 20px; color: var(--text-secondary); }
        .loading::after { content: ""; display: block; width: 32px; height: 32px; margin: 16px auto 0; border: 3px solid var(--border); border-top-color: var(--accent); border-radius: 50%; animation: spin 0.8s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
        .error { background: #f871711a; border: 1px solid #f8717133; color: var(--error); padding: 20px; border-radius: var(--radius); margin: 20px 0; font-size: calc(14px * var(--ui-scale)); }
        .empty-state { text-align: center; padding: 60px 20px; color: var(--text-secondary); }
        .empty-state h3 { font-size: calc(18px * var(--ui-scale)); margin-bottom: 8px; color: var(--text); }
        .more-btn { width: 100%; padding: 14px; background: var(--accent); color: white; border: none; border-radius: var(--radius); font-size: calc(14px * var(--ui-scale)); font-family: var(--font); font-weight: 600; cursor: pointer; margin-top: 16px; transition: all 0.2s; }
        .more-btn:hover { opacity: 0.9; }
        .more-btn:disabled { opacity: 0.4; cursor: not-allowed; }

        /* Modal */
        .modal { display: none; position: fixed; z-index: 2000; left: 0; top: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); backdrop-filter: blur(4px); align-items: center; justify-content: center; }
        .modal.active { display: flex; }
        .modal-content { background: var(--bg-surface); border: 1px solid var(--border); border-radius: 12px; max-width: 560px; width: 92%; max-height: 85vh; overflow-y: auto; box-shadow: var(--shadow); }
        .modal-header { background: var(--bg-elevated); padding: 18px 24px; border-radius: 12px 12px 0 0; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid var(--border); }
        .modal-header h2 { font-size: calc(18px * var(--ui-scale)); font-weight: 700; }
        .close-x { color: var(--text-secondary); font-size: calc(24px * var(--ui-scale)); cursor: pointer; background: none; border: none; padding: 4px 8px; }
        .close-x:hover { color: var(--text); }
        .modal-body { padding: 24px; }
        .sg { margin-bottom: 20px; }
        .sg label { display: block; margin-bottom: 6px; font-size: calc(13px * var(--ui-scale)); font-weight: 600; color: var(--text); }
        .sg .hint { font-size: calc(12px * var(--ui-scale)); color: var(--text-secondary); margin-top: 4px; }
        .sg input[type="text"], .sg input[type="url"] { width: 100%; padding: 10px; background: var(--bg); border: 1px solid var(--border); border-radius: 6px; font-size: calc(14px * var(--ui-scale)); font-family: var(--font); color: var(--text); }
        .sg input:focus { outline: none; border-color: var(--accent); }
        .cbl { display: flex; align-items: center; gap: 8px; cursor: pointer; font-size: calc(14px * var(--ui-scale)); }
        .save-btn { background: var(--accent); color: white; border: none; padding: 12px 24px; border-radius: var(--radius); font-size: calc(14px * var(--ui-scale)); font-family: var(--font); font-weight: 600; cursor: pointer; width: 100%; margin-top: 16px; }
        .rss-item { display: flex; align-items: center; gap: 8px; margin-bottom: 8px; padding: 8px 10px; background: var(--bg); border-radius: 6px; border: 1px solid var(--border); }
        .rss-item span { flex: 1; font-size: calc(12px * var(--ui-scale)); font-family: var(--mono); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .rm-btn { background: var(--error); color: white; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: calc(11px * var(--ui-scale)); }
        .dz { background: #f871710a; border: 1px solid #f8717133; padding: 16px; border-radius: var(--radius); }
        .dz-btn { background: var(--error); color: white; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer; font-size: calc(13px * var(--ui-scale)); font-family: var(--font); margin-top: 10px; }

        @media (max-width: 768px) {
            .header-content { flex-wrap: wrap; }
            main { margin-top: calc(80px + env(safe-area-inset-top)); }
            .stats-bar { gap: 16px; padding: 14px; }
            .stat-value { font-size: calc(18px * var(--ui-scale)); }
            .news-item { padding: 14px; }
            .tab { padding: 8px 12px; font-size: calc(12px * var(--ui-scale)); }
            .modal-content { width: 100%; height: 100%; max-width: 100%; max-height: 100%; border-radius: 0; }
            .modal-header { border-radius: 0; }
        }
        @media (max-width: 480px) { .container { padding: 0 12px; } .news-title { font-size: calc(15px * var(--ui-scale)); } }
        @media (hover: none) and (pointer: coarse) { .news-item:hover { transform: none; border-left-color: transparent; } }
        a, button, input, select, textarea { min-height: 44px; }
        .cmt-toggle { min-height: 28px; }
        html, body { overflow-x: hidden; }
        @supports (-webkit-touch-callout: none) { input, textarea, select { font-size: 16px !important; } }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <div class="header-content">
                <div class="logo">âš¡ Jim's AI <span>News Hub</span></div>
                <div class="header-actions">
                    <div class="time-filter-container">
                        <select id="timeFilterMain" onchange="App.updateTimeFilter(this.value)">
                            <option value="day">24h</option>
                            <option value="week" selected>Week</option>
                            <option value="all">All</option>
                        </select>
                    </div>
                    <button class="btn" id="refreshBtn" onclick="App.refresh()">â†» Refresh</button>
                    <button class="font-btn" id="fontBtn" onclick="App.cycleFont()" title="Font size"><span class="a-small">a</span><span class="a-big">A</span></button>
                    <button class="settings-btn" onclick="App.openSettings()">âš™</button>
                </div>
            </div>
        </div>
    </header>

    <main><div class="container">
        <div id="installPrompt" class="install-prompt">
            <span>ðŸ“± Install AI News Hub for quick access</span>
            <button class="btn" onclick="App.installPWA()" style="min-height:36px">Install</button>
        </div>
        <div class="stats-bar">
            <div class="stat"><span class="stat-label">Fetched</span><span class="stat-value" id="statTotal">â€”</span></div>
            <div class="stat"><span class="stat-label">Shown</span><span class="stat-value" id="statShown">â€”</span></div>
            <div class="stat"><span class="stat-label">Sources</span><span class="stat-value" id="statSources">â€”</span></div>
            <div class="stat"><span class="stat-label">Updated</span><span class="stat-value" id="statTime" style="font-size:13px">â€”</span></div>
        </div>
        <div id="sourceStatus" class="source-status" aria-live="polite"></div>
        <div class="tabs">
            <button class="tab active" onclick="App.switchTab('all',this)">All</button>
            <button class="tab" onclick="App.switchTab('hackernews',this)">HN</button>
            <button class="tab" onclick="App.switchTab('reddit',this)">Reddit</button>
            <button class="tab" onclick="App.switchTab('arxiv',this)">ArXiv</button>
            <button class="tab" onclick="App.switchTab('github',this)">GitHub</button>
            <button class="tab" onclick="App.switchTab('mastodon',this)">Mastodon</button>
            
            <button class="tab" onclick="App.switchTab('rss',this)">RSS</button>
        </div>
        <div id="content"><div class="loading">Loading AI newsâ€¦</div></div>
    </div></main>

    <div id="settingsModal" class="modal">
        <div class="modal-content">
            <div class="modal-header"><h2>Settings</h2><button class="close-x" onclick="App.closeSettings()">&times;</button></div>
            <div class="modal-body">
                <div class="sg"><label class="cbl"><input type="checkbox" id="sFilterEn" checked> Filter non-English articles</label></div>
                <div class="sg"><label class="cbl"><input type="checkbox" id="sStrict" checked> Strict AI filtering</label><p class="hint">Aggressively filters non-AI content. Turn off to see all posts.</p></div>
                <div class="sg"><label>Theme</label><select id="sTheme"><option value="dark">Dark (default)</option><option value="eink">E-ink</option><option value="midnight">Midnight </option></select></div>
                <div class="sg"><label>HN Search Term</label><input type="text" id="sHN" value="AI"><p class="hint">Single keyword for Algolia HN API.</p></div>
                <div class="sg"><label>Reddit Subreddits</label><input type="text" id="sRedditSubs" value="r/artificial, r/MachineLearning, r/singularity, r/OpenAI, r/LocalLLaMA"></div>
                <div class="sg"><label>Reddit Max Age (hours)</label><input type="text" id="sRedditAge" value="24"><p class="hint">Show posts from the last N hours. Default: 24.</p></div>
                <div class="sg"><label>ArXiv Categories</label><input type="text" id="sArxiv" value="cs.AI, cs.LG, cs.CL, cs.CV"><p class="hint">cs.AI, cs.LG, cs.CL, cs.CV, cs.NE, stat.ML</p></div>
                <div class="sg"><label>Mastodon Instance</label><input type="text" id="sMastInst" value="mastodon.social"></div>
                <div class="sg"><label>Mastodon Hashtags</label><input type="text" id="sMastTags" value="#AI, #ArtificialIntelligence, #MachineLearning"></div>
                <div class="sg">
                    <label>RSS Feeds</label>
                    <div id="rssList"></div>
                    <div style="display:flex;gap:8px;margin-top:8px"><input type="url" id="newRss" placeholder="https://example.com/feed.xml" style="flex:1"><button class="btn" onclick="App.addRss()" style="background:var(--success);color:#fff;border:none;min-height:40px">Add</button></div>
                </div>
                <div class="sg"><div class="dz"><p style="font-size:13px">Clear all cached data and reset.</p><button class="dz-btn" onclick="App.clearAll()">Clear All Data</button></div></div>
                <button class="save-btn" onclick="App.saveSettings()">Save Settings</button>
            </div>
        </div>
    </div>

<script>
// Everything in a single IIFE to avoid any global scope issues
const App = (function() {

    // =================== AI SCORING ===================
    const AI_KW = {
        core: ['artificial intelligence','machine learning','deep learning','neural network','large language model','llm','transformer model','natural language processing','computer vision','reinforcement learning','generative ai','foundation model'],
        co: ['openai','anthropic','claude','chatgpt','copilot','gemini','deepmind','hugging face','huggingface','midjourney','stable diffusion','dall-e','cohere','mistral ai','perplexity','meta ai'],
        tech: ['tensorflow','pytorch','diffusion model','attention mechanism','fine-tuning','fine tuning','prompt engineering','retrieval augmented','vector database','embedding','llama','mistral','mixtral','whisper','lora','qlora','gguf','ollama','vllm','langchain','llamaindex'],
        apps: ['ai agent','chatbot','text generation','image generation','code generation','ai assistant','text-to-speech','speech recognition','object detection','ai art','text-to-image','ai coding','ai search','ai safety','ai alignment','ai regulation'],
        research: ['training data','backpropagation','gradient descent','convolutional neural','recurrent neural','lstm','attention head','multimodal','zero-shot','few-shot','transfer learning','chain of thought','reasoning model','scaling law']
    };
    const AI_W = { core:10, co:8, tech:7, apps:6, research:5 };

    function aiScore(title, desc) {
        var text = ((title||'') + ' ' + (desc||'')).toLowerCase();
        var s = 0;
        for (var cat in AI_KW) {
            for (var i = 0; i < AI_KW[cat].length; i++) {
                if (text.indexOf(AI_KW[cat][i]) !== -1) s += AI_W[cat];
            }
        }
        var tl = (title||'').toLowerCase();
        if (/\bai\b/.test(tl)) s += 8;
        if (/\bgpt[-\s]?\d/.test(tl)) s += 8;
        if (/\bllm\b/.test(tl)) s += 8;
        if (/\bclaude\b/.test(tl)) s += 8;
        if (/\bchatgpt\b/.test(tl)) s += 8;
        return s;
    }

    function isAIRelated(a) { return aiScore(a.title, a.description) >= (cfg.strictFiltering ? 5 : 0); }

    // =================== DEDUP ===================
    function normUrl(url) {
        try { var u = new URL(url); ['utm_source','utm_medium','utm_campaign','ref','source','via'].forEach(function(p){u.searchParams.delete(p);}); return u.origin + u.pathname + (u.search||''); }
        catch(e) { return url; }
    }

    function jaccard(a, b) {
        var w1 = a.toLowerCase().replace(/[^\w\s]/g,'').split(/\s+/).filter(function(w){return w.length>2;});
        var w2 = b.toLowerCase().replace(/[^\w\s]/g,'').split(/\s+/).filter(function(w){return w.length>2;});
        var s1 = new Set(w1), s2 = new Set(w2);
        if (!s1.size || !s2.size) return 0;
        var inter = 0; s1.forEach(function(w){ if(s2.has(w)) inter++; });
        return inter / (s1.size + s2.size - inter);
    }

    function dedup(arr) {
        var ids = new Set(), urls = new Set(), titles = [];
        return arr.filter(function(a) {
            if (ids.has(a.id)) return false; ids.add(a.id);
            var nu = normUrl(a.url); if (urls.has(nu)) return false; urls.add(nu);
            for (var i = 0; i < titles.length; i++) { if (jaccard(a.title, titles[i]) > 0.7) return false; }
            titles.push(a.title); return true;
        });
    }

    // =================== LANG ===================
    function isEnglish(text) {
        if (!text) return true;
        // Quick reject: CJK, Japanese, Korean, Arabic, Cyrillic, Devanagari, Thai
        if (/[\u4e00-\u9fff\u3040-\u30ff\uac00-\ud7af\u0600-\u06ff\u0400-\u04ff\u0900-\u097f\u0e00-\u0e7f]/.test(text)) return false;
        // Quick reject: heavy use of non-ASCII Latin diacritics (Czech, Turkish, Polish, etc.)
        var diacritics = text.match(/[Ã Ã¡Ã¢Ã£Ã¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯Ã°Ã±Ã²Ã³Ã´ÃµÃ¶Ã¹ÃºÃ»Ã¼Ã½Ã¾Ã¿Å¡Å¾ÄÅ™ÄÅ¥ÅˆÅ¯Ä›Å‘Å±Ä…Ä‡Ä™Å‚Å„Å›ÅºÅ¼ÄŸÄ±ÅŸÃ¶Ã¼Ã€ÃÃ‚ÃƒÃ„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹ÃŒÃÃŽÃÃÃ‘Ã’Ã“Ã”Ã•Ã–Ã™ÃšÃ›ÃœÃÃžÅ Å½ÄŒÅ˜ÄŽÅ¤Å‡Å®ÄšÅÅ°Ä„Ä†Ä˜ÅÅƒÅšÅ¹Å»ÄžÄ°ÅžÃ–Ãœ]/g) || [];
        var words = text.split(/\s+/).filter(Boolean);
        if (words.length > 3 && diacritics.length / words.length > 0.4) return false;
        // Check for common English stop words â€” English text almost always contains several
        var lc = ' ' + text.toLowerCase() + ' ';
        var eng = [' the ',' is ',' are ',' was ',' were ',' and ',' for ',' that ',' this ',' with ',' from ',' have ',' has ',' will ',' can ',' not ',' but ',' you ',' your ',' what ',' how ',' about ',' into ',' been ',' would ',' should ',' could ',' which ',' their ',' there ',' when ',' than '];
        var hits = 0;
        for (var i = 0; i < eng.length; i++) { if (lc.indexOf(eng[i]) !== -1) hits++; }
        // Short texts (under 5 words) get a pass if mostly ASCII
        if (words.length < 5) {
            var asc = text.match(/[a-zA-Z0-9\s.,!?;:'"()\-\/@#$%^&*_+=~`]/g) || [];
            return (asc.length / text.length) >= 0.8;
        }
        // Longer texts need at least 2 English stop words
        return hits >= 2;
    }

    // =================== STATE ===================
    var db = null;
    var articles = [];
    var totalFetched = 0;
    var currentTab = 'all';
    var deferredPrompt = null;
    var commentCache = {};

    var DB_NAME = 'AINewsHub6';
    var DB_VER = 1;

    var cfg = {
        timeFilter: 'week',
        hnSearchTerm: 'AI',
        redditSubreddits: 'r/artificial, r/MachineLearning, r/singularity, r/OpenAI, r/LocalLLaMA, r/Ollama, r/AgentsOfAI, r/AgentToAgent',
        redditMaxAge: 1,
        arxivCategories: 'cs.AI, cs.LG, cs.CL, cs.CV',
        mastodonInstance: 'mastodon.social',
        mastodonHashtags: '#AI, #ArtificialIntelligence, #MachineLearning',
        rssFeeds: ['https://www.artificialintelligence-news.com/feed/', 'https://openai.com/news/rss.xml', 'https://simonwillison.net/atom/everything/'],
        filterNonEnglish: true,
        strictFiltering: true,
        theme: 'eink'
    };

    var pag = {};
    function resetPag() {
        pag = {
            hackernews: { page:0, hasMore:true, loading:false },
            reddit: { si:0, after:null, hasMore:true, loading:false },
            mastodon: { hi:0, maxId:null, hasMore:true, loading:false },
            arxiv: { hasMore:false, loading:false },
            github: { page:1, hasMore:true, loading:false },
            rss: { hasMore:false, loading:false },
            all: { hasMore:true, loading:false }
        };
    }
    resetPag();

    // =================== IDB ===================
    function initDB() {
        return new Promise(function(resolve, reject) {
            var req = indexedDB.open(DB_NAME, DB_VER);
            req.onerror = function() { reject(req.error); };
            req.onsuccess = function() { db = req.result; resolve(db); };
            req.onupgradeneeded = function(e) {
                db = e.target.result;
                if (!db.objectStoreNames.contains('articles')) {
                    var s = db.createObjectStore('articles', { keyPath: 'id' });
                    s.createIndex('source', 'source', { unique: false });
                    s.createIndex('timestamp', 'timestamp', { unique: false });
                }
                if (!db.objectStoreNames.contains('settings')) {
                    db.createObjectStore('settings', { keyPath: 'key' });
                }
            };
        });
    }

    function loadCfg() {
        return new Promise(function(resolve) {
            var req = db.transaction(['settings'], 'readonly').objectStore('settings').get('config');
            req.onsuccess = function() {
                if (req.result && req.result.value) {
                    var saved = req.result.value;
                    for (var k in saved) { if (saved.hasOwnProperty(k)) cfg[k] = saved[k]; }
                }
                resolve(cfg);
            };
            req.onerror = function() { resolve(cfg); };
        });
    }

    function saveCfg() {
        return new Promise(function(resolve, reject) {
            var req = db.transaction(['settings'], 'readwrite').objectStore('settings').put({ key: 'config', value: cfg });
            req.onsuccess = function() { resolve(); };
            req.onerror = function() { reject(req.error); };
        });
    }

    function loadArticles() {
        return new Promise(function(resolve) {
            var req = db.transaction(['articles'], 'readonly').objectStore('articles').getAll();
            req.onsuccess = function() {
                articles = dedup(req.result || []);
                resolve(articles);
            };
            req.onerror = function() { resolve([]); };
        });
    }

    function saveArt(a) {
        return new Promise(function(resolve, reject) {
            var req = db.transaction(['articles'], 'readwrite').objectStore('articles').put(a);
            req.onsuccess = function() { resolve(); };
            req.onerror = function() { reject(req.error); };
        });
    }

    function clearArts() {
        return new Promise(function(resolve) {
            try {
                var tx = db.transaction(['articles'], 'readwrite');
                tx.objectStore('articles').clear();
                tx.oncomplete = function() { resolve(); };
                tx.onerror = function() { console.warn('clearArts error'); resolve(); };
                tx.onabort = function() { console.warn('clearArts aborted'); resolve(); };
            } catch(e) {
                console.warn('clearArts exception:', e);
                resolve();
            }
        });
    }

    // =================== HELPERS ===================
    function filterByTime(ts) {
        var age = Date.now() - ts, day = 86400000;
        if (cfg.timeFilter === 'day') return age <= day;
        if (cfg.timeFilter === 'week') return age <= 7 * day;
        return true;
    }

    function timeAgo(d) {
        var s = Math.floor((Date.now() - d) / 1000);
        if (s < 60) return 'now';
        if (s < 3600) return Math.floor(s/60) + 'm';
        if (s < 86400) return Math.floor(s/3600) + 'h';
        if (s < 2592000) return Math.floor(s/86400) + 'd';
        if (s < 31536000) return Math.floor(s/2592000) + 'mo';
        return Math.floor(s/31536000) + 'y';
    }

    function esc(text) {
        var d = document.createElement('div');
        d.textContent = text;
        return d.innerHTML;
    }

    function unesc(text) {
        if (!text) return '';
        var d = document.createElement('textarea');
        d.innerHTML = text;
        return d.value;
    }

    function sanitize(html) {
        if (!html) return '';
        var tmp = document.createElement('div');
        tmp.innerHTML = html;
        var bad = tmp.querySelectorAll('script,style,iframe,object,embed,form,input,button');
        for (var i = 0; i < bad.length; i++) bad[i].remove();
        var all = tmp.querySelectorAll('*');
        for (var j = 0; j < all.length; j++) {
            var el = all[j];
            var attrs = [];
            for (var k = 0; k < el.attributes.length; k++) attrs.push(el.attributes[k].name);
            for (var m = 0; m < attrs.length; m++) {
                if (attrs[m].indexOf('on') === 0 || attrs[m] === 'style') el.removeAttribute(attrs[m]);
            }
            if (el.tagName === 'A') { el.setAttribute('target', '_blank'); el.setAttribute('rel', 'noopener noreferrer'); }
        }
        return tmp.innerHTML;
    }

    // =================== CORS ===================
    function fetchWithTimeout(url, options, ms, ctrl) {
        ms = ms || 15000;
        return new Promise(function(resolve, reject) {
            ctrl = ctrl || new AbortController();
            var timer = setTimeout(function() { ctrl.abort(); reject(new Error('Timeout after ' + ms + 'ms')); }, ms);
            var opts = options || {};
            opts.signal = ctrl.signal;
            fetch(url, opts).then(function(r) { clearTimeout(timer); resolve(r); }).catch(function(e) { clearTimeout(timer); reject(e); });
        });
    }

    // =================== REFRESH RUN CONTROL ===================
    var refreshState = { id: 0, inProgress: false, controllers: [] };

    function abortActiveRefresh() {
        try {
            (refreshState.controllers || []).forEach(function(c) { try { c.abort(); } catch (e) {} });
        } catch (e) {}
        refreshState.controllers = [];
        refreshState.inProgress = false;
    }

    function beginRefreshRun() {
        abortActiveRefresh();
        refreshState.id += 1;
        refreshState.inProgress = true;
        return refreshState.id;
    }

    function endRefreshRun(runId) {
        if (runId === refreshState.id) {
            refreshState.inProgress = false;
            refreshState.controllers = [];
        }
    }

    function registerRefreshController(ctrl) {
        if (refreshState.inProgress && ctrl) refreshState.controllers.push(ctrl);
        return ctrl;
    }

    function fetchWithRefreshTimeout(url, options, ms) {
        var ctrl = registerRefreshController(new AbortController());
        return fetchWithTimeout(url, options, ms, ctrl);
    }


    function getCorsProxies() {
        var list = [];
        // Optional: set localStorage.customCorsProxy to your own proxy base (recommended), e.g. 'https://YOUR-WORKER.workers.dev/?url='
        // You can also use a template containing '{url}' which will be replaced with an encoded URL.
        var custom = (localStorage.getItem('customCorsProxy') || '').trim();
        if (custom) {
            list.push(function(u) {
                if (custom.indexOf('{url}') >= 0) return custom.replace('{url}', encodeURIComponent(u));
                return custom + encodeURIComponent(u);
            });
        }
        // Public proxies (best-effort; may rate-limit or block).
        list.push(function(u) { return 'https://corsproxy.io/?' + encodeURIComponent(u); });
        list.push(function(u) { return 'https://api.allorigins.win/raw?url=' + encodeURIComponent(u); });
        list.push(function(u) { return 'https://api.codetabs.com/v1/proxy?quest=' + encodeURIComponent(u); });
        list.push(function(u) { return 'https://thingproxy.freeboard.io/fetch/' + u; });
        return list;
    }


    function fetchCORS(url, opts) {
        // opts can be:
        //  - boolean: skipDirect
        //  - object: { skipDirect: boolean, timeoutMs: number, accept: string }
        var skipDirect = false;
        var timeoutMs = 12000;
        var accept = 'application/rss+xml, application/atom+xml, application/xml, text/xml, */*';

        if (typeof opts === 'boolean') {
            skipDirect = opts;
        } else if (opts && typeof opts === 'object') {
            if (typeof opts.skipDirect === 'boolean') skipDirect = opts.skipDirect;
            if (typeof opts.timeoutMs === 'number') timeoutMs = opts.timeoutMs;
            if (typeof opts.accept === 'string') accept = opts.accept;
        }

        function attemptFetch(targetUrl) {
            return fetchWithRefreshTimeout(targetUrl, {
                method: 'GET',
                headers: {
                    'Accept': accept,
                    // Some endpoints/proxies behave better with an explicit UA.
                    'User-Agent': 'Mozilla/5.0'
                }
            }, timeoutMs).then(function(r) {
                if (!r.ok) throw new Error('HTTP ' + r.status);
                return r.text();
            });
        }

        function viaProxies(reason) {
            var proxies = getCorsProxies();
            var i = 0;

            function tryNext() {
                if (i >= proxies.length) return Promise.reject(new Error('All CORS proxies failed'));
                var proxyUrl = proxies[i++](url);
                return attemptFetch(proxyUrl).catch(function() { return tryNext(); });
            }

            // Keep console noise low; uncomment for debugging:
            // console.log('Using proxy for:', url, reason ? '(' + reason + ')' : '');
            return tryNext();
        }

        if (skipDirect) return viaProxies('skipDirect');

        // Try direct first (works when target provides CORS headers), then proxies.
        return attemptFetch(url).catch(function(e) { return viaProxies(e.message); });
    }


    // Try direct fetch first, then CORS proxies â€” returns parsed JSON
    function fetchJSON(url) {
        function parseResponse(r) {
            var ct = (r.headers.get('content-type') || '').toLowerCase();
            if (ct.indexOf('json') !== -1) return r.json();
            // Some proxies return text/plain â€” try parsing as JSON anyway
            return r.text().then(function(t) {
                try { return JSON.parse(t); }
                catch(e) { throw new Error('Response is not JSON: ' + t.substring(0, 100)); }
            });
        }
        return fetchWithTimeout(url, {}, 12000).then(function(r) {
            if (r.ok) return parseResponse(r);
            throw new Error('HTTP ' + r.status);
        }).catch(function(directErr) {
            console.log('Direct fetch failed (' + directErr.message + '), trying proxies for: ' + url.substring(0, 80));
            var i = 0;
            function tryProxy() {
                if (i >= corsProxies.length) return Promise.reject(new Error('All methods failed for: ' + url.substring(0, 80)));
                var proxyUrl = corsProxies[i++](url);
                return fetchWithTimeout(proxyUrl, {}, 12000).then(function(r) {
                    if (r.ok) return parseResponse(r);
                    console.log('Proxy ' + i + ' returned HTTP ' + r.status);
                    return tryProxy();
                }).catch(function(e) {
                    console.log('Proxy ' + i + ' failed: ' + e.message);
                    return tryProxy();
                });
            }
            return tryProxy();
        });
    }

    // =================== FETCHERS ===================

    
    function fetchHN(loadMore) {
        var termRaw = cfg.hnSearchTerm || 'AI';
        var terms = termRaw.split(',').map(function(s){ return (s || '').trim(); }).filter(Boolean);
        if (!terms.length) terms = ['AI'];

        // Pagination applies to the primary term only (extras are a one-shot enrichment on initial refresh)
        var primary = terms[0];
        var extras = terms.slice(1);

        var page = loadMore ? pag.hackernews.page : 0;
        var ep = (cfg.timeFilter === 'day' || cfg.timeFilter === 'week') ? 'search_by_date' : 'search';

        function fetchTerm(t, pageNum, isExtra) {
            var url = 'https://hn.algolia.com/api/v1/' + ep
                + '?query=' + encodeURIComponent((t || '').trim())
                + '&tags=story&page=' + pageNum + '&hitsPerPage=50';

            return fetchWithRefreshTimeout(url, null, 15000)
                .then(function(r) { return r.json(); })
                .then(function(data) {
                    if (!isExtra) {
                        pag.hackernews.hasMore = pageNum < (data.nbPages || 1) - 1;
                    }
                    if (!data.hits || !data.hits.length) {
                        if (!isExtra) pag.hackernews.hasMore = false;
                        return [];
                    }

                    var rx = new RegExp('\\b' + (t || '').toLowerCase().replace(/[.*+?^${}()|[\\]\\]/g, '\\$&') + '\\b', 'i');
                    var aiRx = /\b(artificial intelligence|machine learning|neural|deep learning|llm|gpt|transformer|chatgpt|openai|anthropic|claude|agentic|agents?)\b/i;

                    return data.hits.filter(function(s) {
                        var c = (s.title || '') + ' ' + (s.story_text || '');
                        if (cfg.filterNonEnglish && !isEnglish(c)) return false;
                        if (!filterByTime(new Date(s.created_at).getTime())) return false;
                        return rx.test(c) || aiRx.test(c);
                    }).map(function(s) {
                        return {
                            id: 'hn_' + s.objectID,
                            title: unesc(s.title || 'Untitled'),
                            url: s.url || ('https://news.ycombinator.com/item?id=' + s.objectID),
                            description: s.story_text ? unesc(s.story_text.replace(/<[^>]*>/g, '')).substring(0, 200) : '',
                            source: 'hackernews',
                            timestamp: new Date(s.created_at).getTime(),
                            points: s.points || 0,
                            comments: s.num_comments || 0
                        };
                    });
                });
        }

        var tasks = [];
        tasks.push(fetchTerm(primary, page, false));

        if (!loadMore && extras.length) {
            extras.forEach(function(t) {
                tasks.push(fetchTerm(t, 0, true).catch(function(){ return []; }));
            });
        }

        return Promise.all(tasks).then(function(parts) {
            var flat = [];
            parts.forEach(function(arr){ if (arr && arr.length) flat = flat.concat(arr); });

            // Dedupe by HN objectID (id already 'hn_<objectID>')
            var seen = Object.create(null);
            var arts = [];
            flat.forEach(function(a) {
                if (!a || !a.id) return;
                if (seen[a.id]) return;
                seen[a.id] = true;
                arts.push(a);
            });

            // Update paging only for primary term
            pag.hackernews.page = loadMore ? page + 1 : 1;

            var p = Promise.resolve();
            arts.forEach(function(a) { p = p.then(function() { return saveArt(a); }); });
            return p.then(function() { return arts; });
        }).catch(function(e) {
            console.error('HN error:', e);
            pag.hackernews.hasMore = false;
            return [];
        });
    }

    function fetchReddit(loadMore) {
        var subs = cfg.redditSubreddits.split(',').map(function(s){return s.trim();}).filter(Boolean);
        var maxAgeMs = (parseFloat(cfg.redditMaxAge) || 24) * 3600000;
        if (loadMore) { pag.reddit.hasMore = false; return Promise.resolve([]); }
        var chain = Promise.resolve([]);

        subs.forEach(function(sub) {
            chain = chain.then(function(all) {
                // Use RSS/Atom feed â€” much more reliable than JSON API (no CORS issues via proxy)
                var rssUrl = 'https://www.reddit.com/' + sub + '/new/.rss?limit=50';
                return fetchCORS(rssUrl).then(function(xml) {
                    var doc = new DOMParser().parseFromString(xml, 'text/xml');
                    if (doc.querySelector('parsererror')) {
                        console.warn('Reddit RSS parse error for ' + sub);
                        return all;
                    }
                    var cutoff = Date.now() - maxAgeMs;
                    var entries = doc.querySelectorAll('entry');
                    var posts = [];
                    for (var i = 0; i < entries.length; i++) {
                        var entry = entries[i];
                        var title = (entry.querySelector('title') || {}).textContent || '';
                        var linkEl = entry.querySelector('link');
                        var link = linkEl ? (linkEl.getAttribute('href') || linkEl.textContent || '') : '';
                        var updated = (entry.querySelector('updated') || {}).textContent || '';
                        var contentEl = entry.querySelector('content');
                        var content = contentEl ? contentEl.textContent || '' : '';
                        var idEl = entry.querySelector('id');
                        var entryId = idEl ? idEl.textContent || '' : '';
                        var authorEl = entry.querySelector('author name');
                        var author = authorEl ? authorEl.textContent || '' : '';
                        var ts = updated ? new Date(updated).getTime() : Date.now();
                        if (ts < cutoff) continue;
                        if (cfg.filterNonEnglish && !isEnglish(title + ' ' + content.replace(/<[^>]*>/g, ''))) continue;
                        // Extract Reddit post ID from the entry id (e.g. "t3_1abc123")
                        var redditId = entryId.replace(/.*t3_/, '').replace(/[^a-zA-Z0-9]/g, '');
                        if (!redditId) redditId = btoa(link).replace(/[^a-zA-Z0-9]/g, '').substring(0, 15);
                        // Extract plain text description from HTML content
                        var desc = content.replace(/<[^>]*>/g, '').substring(0, 200);
                        posts.push({
                            id: 'reddit_' + redditId,
                            title: unesc(title.trim()),
                            url: link,
                            description: unesc(desc),
                            source: 'reddit',
                            subreddit: sub,
                            timestamp: ts,
                            author: author,
                            score: 0,
                            comments: 0
                        });
                    }
                    var sp = Promise.resolve();
                    posts.forEach(function(p) { sp = sp.then(function(){return saveArt(p);}); });
                    return sp.then(function() { return all.concat(posts); });
                }).catch(function(e) {
                    console.error('Reddit RSS error for ' + sub + ':', e);
                    return all;
                });
            });
        });

        return chain;
    }

    function fetchArXiv() {
        var cats = cfg.arxivCategories.split(',').map(function(c){return c.trim();}).filter(Boolean);
        var chain = Promise.resolve([]);
        cats.forEach(function(cat) {
            chain = chain.then(function(all) {
                return fetchCORS('https://export.arxiv.org/api/query?search_query=cat:' + cat + '&sortBy=submittedDate&sortOrder=descending&max_results=15', true).then(function(xml) {
                    var doc = new DOMParser().parseFromString(xml, 'text/xml');
                    if (doc.querySelector('parsererror')) return all;
                    var entries = doc.querySelectorAll('entry');
                    var newArts = [];
                    for (var i = 0; i < entries.length; i++) {
                        var e = entries[i];
                        var id = (e.querySelector('id') || {}).textContent || '';
                        var title = (e.querySelector('title') || {}).textContent || '';
                        title = title.replace(/\n/g, ' ').trim();
                        var summary = (e.querySelector('summary') || {}).textContent || '';
                        var pub = (e.querySelector('published') || {}).textContent || '';
                        var authEls = e.querySelectorAll('author name');
                        var authors = [];
                        for (var j = 0; j < Math.min(authEls.length, 3); j++) authors.push(authEls[j].textContent);
                        if (title && id) {
                            var ts = new Date(pub).getTime();
                            if (filterByTime(ts)) {
                                newArts.push({ id: 'arxiv_' + id.split('/').pop().replace(/[^a-zA-Z0-9.]/g, '_'), title: unesc(title), url: id, source: 'arxiv', timestamp: ts, description: unesc((authors.length ? authors.join(', ') + ' â€” ' : '') + summary.replace(/\n/g, ' ').substring(0, 200)) });
                            }
                        }
                    }
                    var sp = Promise.resolve();
                    newArts.forEach(function(a) { sp = sp.then(function(){return saveArt(a);}); });
                    return sp.then(function() { return all.concat(newArts); });
                }).catch(function(e) { console.error('ArXiv error ' + cat + ':', e); return all; });
            });
        });
        return chain;
    }

    function fetchGitHub(loadMore) {
        var page = loadMore ? pag.github.page : 1;
        return fetchWithRefreshTimeout('https://api.github.com/search/repositories?q=topic:machine-learning+topic:artificial-intelligence+language:python&sort=updated&order=desc&per_page=20&page=' + page, null, 15000)
            .then(function(r) { if (!r.ok) { pag.github.hasMore = false; return []; } return r.json(); })
            .then(function(d) {
                if (Array.isArray(d)) return []; // error response
                pag.github.hasMore = d.items && d.items.length === 20;
                pag.github.page = page + 1;
                var repos = (d.items || []).filter(function(r) { return filterByTime(new Date(r.pushed_at).getTime()); }).map(function(r) {
                    return { id: 'github_' + r.id, title: unesc((r.full_name + ': ' + (r.description || 'No description')).substring(0, 150)), url: r.html_url, source: 'github', timestamp: new Date(r.pushed_at).getTime(), description: 'â­ ' + r.stargazers_count.toLocaleString() + ' stars Â· ' + (r.language || 'Multi'), stars: r.stargazers_count };
                });
                var sp = Promise.resolve();
                repos.forEach(function(a) { sp = sp.then(function(){return saveArt(a);}); });
                return sp.then(function() { return repos; });
            }).catch(function(e) { console.error('GitHub error:', e); pag.github.hasMore = false; return []; });
    }

    function fetchMastodon(loadMore) {
        var inst = cfg.mastodonInstance || 'mastodon.social';
        var tags = cfg.mastodonHashtags.split(',').map(function(h){return h.trim().replace('#','');}).filter(Boolean);
        var si = loadMore ? pag.mastodon.hi : 0;
        var mx = loadMore ? Math.min(si + 2, tags.length) : tags.length;
        var chain = Promise.resolve([]);

        for (var idx = si; idx < mx; idx++) {
            (function(i) {
                chain = chain.then(function(all) {
                    var url = 'https://' + inst + '/api/v1/timelines/tag/' + tags[i] + '?limit=20';
                    if (loadMore && pag.mastodon.maxId && i === si) url += '&max_id=' + pag.mastodon.maxId;
                    return fetchWithRefreshTimeout(url, null, 15000).then(function(r){return r.json();}).then(function(toots) {
                        if (toots.length > 0) { pag.mastodon.maxId = toots[toots.length-1].id; pag.mastodon.hasMore = true; }
                        else if (i === tags.length - 1) pag.mastodon.hasMore = false;
                        var posts = toots.filter(function(t) {
                            var txt = t.content.replace(/<[^>]*>/g, '');
                            if (cfg.filterNonEnglish && !isEnglish(txt)) return false;
                            return filterByTime(new Date(t.created_at).getTime());
                        }).map(function(t) {
                            var txt = t.content.replace(/<[^>]*>/g, '');
                            return { id: 'mastodon_' + t.id, title: unesc(txt.substring(0, 120) + (txt.length > 120 ? 'â€¦' : '')), url: t.url, description: unesc(txt.substring(0, 200)), source: 'mastodon', instance: inst, hashtag: tags[i], timestamp: new Date(t.created_at).getTime(), boosts: t.reblogs_count, favorites: t.favourites_count };
                        });
                        var sp = Promise.resolve();
                        posts.forEach(function(p) { sp = sp.then(function(){return saveArt(p);}); });
                        return sp.then(function() { return all.concat(posts); });
                    }).catch(function(e) { console.error('Mastodon #' + tags[i] + ' error:', e); return all; });
                });
            })(idx);
        }

        return chain.then(function(all) { pag.mastodon.hi = mx % tags.length; return all; });
    }

    function fetchRSS() {
        var chain = Promise.resolve([]);
        cfg.rssFeeds.forEach(function(feedUrl) {
            chain = chain.then(function(all) {
                return fetchCORS(feedUrl, true).then(function(xml) {
                    var doc = new DOMParser().parseFromString(xml, 'text/xml');
                    if (doc.querySelector('parsererror')) return all;
                    var items = doc.querySelectorAll('item, entry');
                    var newArts = [];
                    for (var i = 0; i < items.length; i++) {
                        var item = items[i];
                        var title = (item.querySelector('title') || {}).textContent || '';
                        var linkEl = item.querySelector('link');
                        var link = linkEl ? (linkEl.textContent || linkEl.getAttribute('href') || '') : '';
                        var descEl = item.querySelector('description, summary, content');
                        var desc = descEl ? descEl.textContent || '' : '';
                        var pubEl = item.querySelector('pubDate, published, updated');
                        var pub = pubEl ? pubEl.textContent || '' : '';
                        if (cfg.filterNonEnglish && !isEnglish(title + ' ' + desc)) continue;
                        var ts = pub ? new Date(pub).getTime() : Date.now();
                        if (!filterByTime(ts)) continue;
                        var aid = link ? 'rss_' + btoa(link).replace(/[^a-zA-Z0-9]/g, '').substring(0, 20) : 'rss_' + btoa(title).replace(/[^a-zA-Z0-9]/g, '').substring(0, 20);
                        newArts.push({ id: aid, title: unesc(title.trim()), url: link, description: unesc(desc.replace(/<[^>]*>/g, '').substring(0, 200)), source: 'rss', feedUrl: feedUrl, timestamp: ts });
                    }
                    var sp = Promise.resolve();
                    newArts.forEach(function(a) { sp = sp.then(function(){return saveArt(a);}); });
                    return sp.then(function() { return all.concat(newArts); });
                }).catch(function(e) { console.error('RSS error ' + feedUrl + ':', e); return all; });
            });
        });
        return chain;
    }

    // =================== COMMENTS ===================

    function toggleComments(btn, artId, source) {
        var thread = document.getElementById('ct_' + artId);
        if (!thread) return;
        if (thread.classList.contains('open')) {
            thread.classList.remove('open'); btn.classList.remove('open'); return;
        }
        btn.classList.add('open'); thread.classList.add('open');
        if (commentCache[artId]) { thread.innerHTML = commentCache[artId]; return; }
        thread.innerHTML = '<div class="cmt-loading">Loading commentsâ€¦</div>';

        var p;
        if (source === 'hackernews') p = fetchHNComments(artId);
        else if (source === 'reddit') p = fetchRedditComments(artId);
        else if (source === 'mastodon') p = fetchMastComments(artId);
        else { thread.innerHTML = '<div class="cmt-loading">No comments available.</div>'; return; }

        p.then(function(html) {
            if (!html) html = '<div class="cmt-loading">No comments found.</div>';
            commentCache[artId] = html;
            thread.innerHTML = html;
        }).catch(function(e) {
            console.error('Comments error:', e);
            thread.innerHTML = '<div class="cmt-loading">Failed to load comments.</div>';
        });
    }

    function fetchHNComments(artId) {
        var hnId = artId.replace('hn_', '');
        return fetch('https://hn.algolia.com/api/v1/items/' + hnId).then(function(r){return r.json();}).then(function(d) {
            if (!d.children || !d.children.length) return '';
            return renderHNTree(d.children, 0, 3);
        });
    }

    function renderHNTree(children, depth, maxD) {
        if (!children || !children.length || depth > maxD) return '';
        var lim = depth === 0 ? 10 : 4;
        var vis = children.slice(0, lim);
        var rem = children.length - lim;
        var h = '';
        for (var i = 0; i < vis.length; i++) {
            var c = vis[i];
            if (!c.text) continue;
            var nested = '';
            if (depth < maxD && c.children && c.children.length) {
                nested = '<div class="comment-nest">' + renderHNTree(c.children, depth+1, maxD) + '</div>';
            } else if (c.children && c.children.length) {
                nested = '<div class="comment-nest"><div class="cmt-loading" style="font-style:normal;padding:6px 0">' + c.children.length + ' moreâ€¦</div></div>';
            }
            h += '<div class="comment"><div class="cmt-author">' + esc(c.author || 'anon') + '<span class="cmt-time">' + timeAgo(new Date(c.created_at)) + '</span></div><div class="cmt-body">' + sanitize(c.text) + '</div>' + nested + '</div>';
        }
        if (rem > 0) h += '<div style="padding:6px 0;color:var(--text-secondary);font-size:12px;font-family:var(--mono)">+ ' + rem + ' more</div>';
        return h;
    }

    function fetchRedditComments(artId) {
        var rid = artId.replace('reddit_', '');
        var art = articles.find(function(a){return a.id===artId;});
        var sub = (art && art.subreddit) ? art.subreddit : 'all';
        return fetchJSON('https://www.reddit.com/' + sub + '/comments/' + rid + '.json?limit=15&depth=3&sort=best')
            .then(function(d) {
                if (!Array.isArray(d) || d.length < 2) return '';
                return renderRedditTree(d[1].data.children || [], 0, 3);
            });
    }

    function renderRedditTree(children, depth, maxD) {
        if (!children || !children.length || depth > maxD) return '';
        var t1 = children.filter(function(c){return c.kind==='t1';});
        var lim = depth === 0 ? 10 : 4;
        var vis = t1.slice(0, lim);
        var rem = t1.length - lim;
        var h = '';
        for (var i = 0; i < vis.length; i++) {
            var d = vis[i].data;
            if (!d.body) continue;
            var replies = (d.replies && d.replies.data && d.replies.data.children) ? d.replies.data.children : [];
            var nested = (depth < maxD && replies.length) ? '<div class="comment-nest">' + renderRedditTree(replies, depth+1, maxD) + '</div>' : '';
            var body = '';
            if (d.body_html) {
                var ta = document.createElement('textarea');
                ta.innerHTML = d.body_html;
                body = sanitize(ta.value);
            } else {
                body = esc(d.body);
            }
            h += '<div class="comment"><div class="cmt-author">' + esc(d.author || '[deleted]') + '<span class="cmt-score">â†‘' + (d.score||0) + '</span><span class="cmt-time">' + timeAgo(new Date(d.created_utc*1000)) + '</span></div><div class="cmt-body">' + body + '</div>' + nested + '</div>';
        }
        if (rem > 0) h += '<div style="padding:6px 0;color:var(--text-secondary);font-size:12px;font-family:var(--mono)">+ ' + rem + ' more</div>';
        return h;
    }

    function fetchMastComments(artId) {
        var tid = artId.replace('mastodon_', '');
        var art = articles.find(function(a){return a.id===artId;});
        var inst = (art && art.instance) ? art.instance : cfg.mastodonInstance;
        return fetch('https://' + inst + '/api/v1/statuses/' + tid + '/context')
            .then(function(r){return r.json();}).then(function(d) {
                var desc = d.descendants || [];
                if (!desc.length) return '';
                var vis = desc.slice(0, 10);
                var rem = desc.length - 10;
                var h = '';
                for (var i = 0; i < vis.length; i++) {
                    var t = vis[i];
                    var name = (t.account && (t.account.display_name || t.account.username)) || 'anon';
                    h += '<div class="comment"><div class="cmt-author">' + esc(name) + '<span class="cmt-time">' + timeAgo(new Date(t.created_at)) + '</span>' + (t.favourites_count ? '<span class="cmt-score">â¤ ' + t.favourites_count + '</span>' : '') + '</div><div class="cmt-body">' + sanitize(t.content || '') + '</div></div>';
                }
                if (rem > 0) h += '<div style="padding:6px 0;color:var(--text-secondary);font-size:12px;font-family:var(--mono)">+ ' + rem + ' more</div>';
                return h;
            });
    }

    // =================== RENDER ===================

    function render() {
        var el = document.getElementById('content');
        var list = articles;
        if (currentTab !== 'all') list = articles.filter(function(a){return a.source===currentTab;});
        list.sort(function(a,b){return b.timestamp-a.timestamp;});

        if (!list.length) {
            el.innerHTML = '<div class="empty-state"><h3>No articles found</h3><p>Try refreshing or adjusting settings.</p></div>';
            return;
        }

        var html = '';
        for (var i = 0; i < list.length; i++) {
            var a = list[i];
            var t = timeAgo(new Date(a.timestamp));
            var sc = aiScore(a.title, a.description);
            var meta = [t];
            if (a.subreddit) meta.push(a.subreddit);
            if (a.hashtag) meta.push('#' + a.hashtag);
            if (a.points !== undefined) meta.push(a.points + ' pts');
            if (a.score !== undefined && a.source === 'reddit') meta.push('â†‘' + a.score);
            if (a.boosts !== undefined) meta.push('ðŸ” ' + a.boosts);
            if (a.favorites !== undefined) meta.push('â¤ ' + a.favorites);
            if (a.stars !== undefined) meta.push('â­ ' + a.stars.toLocaleString());

            var hasCmt = (a.source === 'hackernews' || a.source === 'reddit' || a.source === 'mastodon');
            var cmtBtn = '';
            if (a.source === 'hackernews' && a.comments !== undefined) {
                cmtBtn = '<button class="cmt-toggle" onclick="event.stopPropagation();App.toggleCmt(this,\'' + a.id + '\',\'hackernews\')"><span class="arr">â–¶</span> ' + a.comments + ' comments</button>';
            } else if (a.source === 'reddit' && a.comments !== undefined) {
                cmtBtn = '<button class="cmt-toggle" onclick="event.stopPropagation();App.toggleCmt(this,\'' + a.id + '\',\'reddit\')"><span class="arr">â–¶</span> ' + a.comments + ' comments</button>';
            } else if (a.source === 'mastodon') {
                cmtBtn = '<button class="cmt-toggle" onclick="event.stopPropagation();App.toggleCmt(this,\'' + a.id + '\',\'mastodon\')"><span class="arr">â–¶</span> replies</button>';
            } else if (a.comments !== undefined) {
                meta.push('ðŸ’¬ ' + a.comments);
            }

            var extLink = '';
            if (a.source === 'hackernews') {
                var hid = a.id.replace('hn_', '');
                extLink = '<a href="https://news.ycombinator.com/item?id=' + hid + '" class="comments-link" target="_blank" onclick="event.stopPropagation()">â†— HN</a>';
            }

            html += '<div class="news-item"><div class="news-header"><span class="source-badge badge-' + a.source + '">' + a.source + '</span>' + (sc > 12 ? '<span class="ai-score">AI:' + sc + '</span>' : '') + '</div>';
            html += '<a href="' + a.url + '" class="news-title" target="_blank">' + esc(a.title) + '</a>';
            html += '<div class="news-meta">';
            for (var j = 0; j < meta.length; j++) html += '<span>' + meta[j] + '</span>';
            html += cmtBtn + extLink + '</div>';
            if (a.description) html += '<div class="news-description">' + esc(a.description) + '</div>';
            if (hasCmt) html += '<div class="cmt-thread" id="ct_' + a.id + '"></div>';
            html += '</div>';
        }

        el.innerHTML = html;

        var ps = pag[currentTab];
        if (ps && ps.hasMore && list.length > 0) {
            el.insertAdjacentHTML('beforeend', '<button class="more-btn" onclick="App.loadMore()">Load More</button>');
        }
    }

    // =================== REFRESH ===================

    
    function updateSourceStatusUI(sourceStatus) {
        var el = document.getElementById('sourceStatus');
        if (!el) return;
        if (!sourceStatus) { el.innerHTML = ''; return; }
        var parts = [];
        for (var k in sourceStatus) {
            if (!Object.prototype.hasOwnProperty.call(sourceStatus, k)) continue;
            var v = sourceStatus[k];
            var cls = 'src-pill';
            if (typeof v === 'string' && v.indexOf('âœ“') === 0) cls += ' ok';
            else if (typeof v === 'string' && v.indexOf('âœ—') === 0) cls += ' bad';
            else cls += ' pending';
            parts.push('<span class="' + cls + '">' + esc(k + ': ' + v) + '</span>');
        }
        el.innerHTML = parts.join('');
    }

function refresh() {
        var runId = beginRefreshRun();
        var statusEl = document.getElementById('content');
        var refreshBtn = document.getElementById('refreshBtn');

        if (refreshBtn) { refreshBtn.disabled = true; refreshBtn.textContent = 'â†» Refreshingâ€¦'; }

        // Show loading state, but we'll progressively render as each source returns.
        statusEl.innerHTML = '<div class="loading">Fetching AI newsâ€¦</div>';
        resetPag();
        commentCache = {};

        var sourceStatus = { 'HN': 'â€¦', 'Reddit': 'â€¦', 'ArXiv': 'â€¦', 'GitHub': 'â€¦', 'Mastodon': 'â€¦', 'RSS': 'â€¦' };
        updateSourceStatusUI(sourceStatus);

        function guard() { return runId === refreshState.id; }

        function finish() {
            if (!guard()) return;
            endRefreshRun(runId);
            if (refreshBtn) { refreshBtn.disabled = false; refreshBtn.textContent = 'â†» Refresh'; }
        }

        // Allow per-source timeouts (mobile networks can be slow for RSS/proxies)
        function wrapFetch(name, promise, timeoutMs) {
            var timer = null;
            var ms = timeoutMs || 45000;
            var timeout = new Promise(function(resolve) {
                timer = setTimeout(function() {
                    if (!guard()) return resolve([]);
                    sourceStatus[name] = 'âœ— timeout';
                    updateSourceStatusUI(sourceStatus);
                    console.warn(name + ' timed out after ' + Math.round(ms/1000) + 's');
                    resolve([]);
                }, ms);
            });

            return Promise.race([promise, timeout]).then(function(results) {
                if (timer) clearTimeout(timer);
                if (!guard()) return [];
                // Only mark success if not already error/timeout
                if (!sourceStatus[name] || sourceStatus[name] === 'â€¦') sourceStatus[name] = 'âœ“ ' + results.length;
                updateSourceStatusUI(sourceStatus);
                return results;
            }).catch(function(e) {
                if (timer) clearTimeout(timer);
                if (!guard()) return [];
                sourceStatus[name] = 'âœ— error';
                updateSourceStatusUI(sourceStatus);
                console.error(name + ' failed:', e);
                return [];
            });
        }

        // Progressive aggregation + render
        var collected = [];
        var renderedOnce = false;

        function incorporate(newItems) {
            if (!guard()) return;
            if (!newItems || !newItems.length) return;

            collected = collected.concat(newItems);
            totalFetched = collected.length;

            var filtered = cfg.strictFiltering ? collected.filter(isAIRelated) : collected;
            articles = dedup(filtered);

            updateStats();
            render();
            renderedOnce = true;
        }

        // If everything times out/errors, keep a friendly message
        function showEmptyIfNeeded() {
            if (!guard()) return;
            if (!renderedOnce) {
                statusEl.innerHTML = '<div class="error">No results yet (some sources may be slow or blocked). Try again, or change networks.</div>';
            }
        }

        // Start clearing IndexedDB, but don't block progressive rendering on it.
        clearArts().catch(function(e){ console.warn('clearArts failed:', e); });

        totalFetched = 0;
        articles = [];
        updateStats();

        var tasks = [
            wrapFetch('HN', fetchHN(false), 45000).then(incorporate),
            wrapFetch('Reddit', fetchReddit(false), 60000).then(incorporate),
            wrapFetch('ArXiv', fetchArXiv(), 45000).then(incorporate),
            wrapFetch('GitHub', fetchGitHub(false), 45000).then(incorporate),
            wrapFetch('Mastodon', fetchMastodon(false), 45000).then(incorporate),
            wrapFetch('RSS', fetchRSS(), 60000).then(incorporate)
        ];

        // Finalize when all sources have settled
        Promise.allSettled(tasks).then(function() {
            if (!guard()) return;
            document.getElementById('statTime').textContent = new Date().toLocaleTimeString([], {hour:'numeric',minute:'2-digit'});

            // Log source status
            var statusParts = [];
            for (var k in sourceStatus) statusParts.push(k + ': ' + sourceStatus[k]);
            console.log('Source status: ' + statusParts.join(' | '));

            showEmptyIfNeeded();
        }).catch(function(e) {
            if (!guard()) return;
            console.error('Refresh error:', e);
            statusEl.innerHTML = '<div class="error">Error fetching news. Please try refreshing.</div>';
        }).finally(function() {
            finish();
        });
    }
    function updateStats() {
        document.getElementById('statTotal').textContent = totalFetched;
        document.getElementById('statShown').textContent = articles.length;
        document.getElementById('statSources').textContent = new Set(articles.map(function(a){return a.source;})).size;
    }

    function loadMore() {
        if (pag[currentTab] && pag[currentTab].loading) return;
        pag[currentTab].loading = true;
        var btn = document.querySelector('.more-btn');
        if (btn) { btn.disabled = true; btn.textContent = 'Loadingâ€¦'; }

        var p;
        if (currentTab === 'all') {
            p = Promise.all([
                pag.hackernews.hasMore ? fetchHN(true) : Promise.resolve([]),
                pag.reddit.hasMore ? fetchReddit(true) : Promise.resolve([]),
                pag.mastodon.hasMore ? fetchMastodon(true) : Promise.resolve([]),
                pag.github.hasMore ? fetchGitHub(true) : Promise.resolve([])
            ]).then(function(r) {
                var na = []; for (var i=0;i<r.length;i++) na = na.concat(r[i]);
                pag.all.hasMore = pag.hackernews.hasMore || pag.reddit.hasMore || pag.mastodon.hasMore || pag.github.hasMore;
                return na;
            });
        } else if (currentTab === 'hackernews') p = fetchHN(true);
        else if (currentTab === 'reddit') p = fetchReddit(true);
        else if (currentTab === 'mastodon') p = fetchMastodon(true);
        else if (currentTab === 'github') p = fetchGitHub(true);
        else p = Promise.resolve([]);

        p.then(function(na) {
            pag[currentTab].loading = false;
            if (na.length > 0) {
                var ids = new Set(articles.map(function(a){return a.id;}));
                var u = na.filter(function(a){return !ids.has(a.id);});
                articles = articles.concat(cfg.strictFiltering ? u.filter(isAIRelated) : u);
            }
            render();
        });
    }

    // =================== UI ===================

    function updateTimeFilter(v) { cfg.timeFilter = v; saveCfg().then(refresh); }

    function switchTab(tab, el) {
        currentTab = tab;
        var tabs = document.querySelectorAll('.tab');
        for (var i = 0; i < tabs.length; i++) tabs[i].classList.remove('active');
        if (el) el.classList.add('active');
        render();
    }

    function applyTheme() {
        var r = document.documentElement;
        r.classList.remove('eink', 'midnight');
        if (cfg.theme === 'eink') r.classList.add('eink');
        else if (cfg.theme === 'midnight') r.classList.add('midnight');
        var colors = { dark: '#1a1a2e', eink: '#ffffff', midnight: '#000000' };
        document.querySelector('meta[name="theme-color"]').setAttribute('content', colors[cfg.theme] || colors.dark);
    }

    // Font scaling (A/a button)
    var FONT_SCALES = ['0','1','2']; // maps to html[data-font]
    function applyFontScale() {
        var idx = 0;
        try {
            var saved = localStorage.getItem('aiNewsFont') || '';
            idx = Math.max(0, Math.min(FONT_SCALES.length - 1, parseInt(saved || '0', 10) || 0));
        } catch(e) { idx = 0; }
        document.documentElement.setAttribute('data-font', FONT_SCALES[idx]);
        updateFontButton(idx);
        return idx;
    }

    function updateFontButton(idx) {
        var btn = document.getElementById('fontBtn');
        if (!btn) return;
        // subtle visual cue: bold the big A more as size increases
        btn.style.opacity = '1';
        btn.setAttribute('aria-label', 'Font size ' + (idx + 1) + ' of ' + FONT_SCALES.length);
        btn.setAttribute('title', 'Font size (' + (idx + 1) + '/' + FONT_SCALES.length + ')');
    }

    function cycleFont() {
        var idx = 0;
        try { idx = parseInt(localStorage.getItem('aiNewsFont') || '0', 10) || 0; } catch(e) { idx = 0; }
        idx = (idx + 1) % FONT_SCALES.length;
        try { localStorage.setItem('aiNewsFont', String(idx)); } catch(e) {}
        document.documentElement.setAttribute('data-font', FONT_SCALES[idx]);
        updateFontButton(idx);
        // re-render masonry-ish layout
        render();
    }

    function openSettings() {
        document.getElementById('settingsModal').classList.add('active');
        document.getElementById('sFilterEn').checked = cfg.filterNonEnglish !== false;
        document.getElementById('sStrict').checked = cfg.strictFiltering !== false;
        document.getElementById('sTheme').value = cfg.theme || 'eink';
        document.getElementById('sHN').value = cfg.hnSearchTerm || 'AI';
        document.getElementById('sRedditSubs').value = cfg.redditSubreddits || '';
        document.getElementById('sRedditAge').value = cfg.redditMaxAge || 1;
        document.getElementById('sArxiv').value = cfg.arxivCategories || '';
        document.getElementById('sMastInst').value = cfg.mastodonInstance || '';
        document.getElementById('sMastTags').value = cfg.mastodonHashtags || '';
        renderRss();
    }

    function closeSettings() { document.getElementById('settingsModal').classList.remove('active'); }

    function renderRss() {
        var el = document.getElementById('rssList');
        var h = '';
        for (var i = 0; i < cfg.rssFeeds.length; i++) {
            h += '<div class="rss-item"><span>' + cfg.rssFeeds[i] + '</span><button class="rm-btn" onclick="App.rmRss(' + i + ')">âœ•</button></div>';
        }
        el.innerHTML = h;
    }

    function addRss() {
        var inp = document.getElementById('newRss');
        var u = inp.value.trim();
        if (u && cfg.rssFeeds.indexOf(u) === -1) { cfg.rssFeeds.push(u); inp.value = ''; renderRss(); }
    }

    function rmRss(i) { cfg.rssFeeds.splice(i, 1); renderRss(); }

    function saveSettings() {
        cfg.filterNonEnglish = document.getElementById('sFilterEn').checked;
        cfg.strictFiltering = document.getElementById('sStrict').checked;
        cfg.theme = document.getElementById('sTheme').value || 'dark';
        cfg.hnSearchTerm = document.getElementById('sHN').value.trim() || 'AI';
        cfg.redditSubreddits = document.getElementById('sRedditSubs').value;
        cfg.redditMaxAge = parseFloat(document.getElementById('sRedditAge').value) || 1;
        cfg.arxivCategories = document.getElementById('sArxiv').value;
        cfg.mastodonInstance = document.getElementById('sMastInst').value;
        cfg.mastodonHashtags = document.getElementById('sMastTags').value;
        applyTheme();
        saveCfg().then(function() { closeSettings(); resetPag(); refresh(); });
    }

    function clearAll() {
        if (!confirm('Clear all cached data? Cannot be undone.')) return;
        clearArts().then(function() {
            var tx = db.transaction(['settings'], 'readwrite');
            tx.objectStore('settings').clear();
            articles = []; totalFetched = 0; commentCache = {};
            cfg = {timeFilter:'week',hnSearchTerm:'AI',redditSubreddits:'r/artificial, r/MachineLearning, r/singularity, r/OpenAI, r/LocalLLaMA',redditMaxAge:1,arxivCategories:'cs.AI, cs.LG, cs.CL, cs.CV',mastodonInstance:'mastodon.social',mastodonHashtags:'#AI, #ArtificialIntelligence, #MachineLearning',rssFeeds:['https://www.artificialintelligence-news.com/feed/','https://openai.com/news/rss.xml','https://simonwillison.net/atom/everything/'],filterNonEnglish:true,strictFiltering:true,theme:'midnight'};
            applyTheme(); resetPag(); render(); closeSettings();
        });
    }

    // =================== PWA ===================

    window.addEventListener('beforeinstallprompt', function(e) {
        e.preventDefault(); deferredPrompt = e;
        document.getElementById('installPrompt').classList.add('show');
    });

    function installPWA() {
        if (deferredPrompt) {
            deferredPrompt.prompt();
            deferredPrompt.userChoice.then(function(r) {
                if (r.outcome === 'accepted') document.getElementById('installPrompt').classList.remove('show');
                deferredPrompt = null;
            });
        }
    }

    function setupPWA() {
        var m = {name:'AI News Hub',short_name:'AI News',description:'Curated AI news',start_url:location.href,display:'standalone',background_color:'#0f0f1a',theme_color:'#1a1a2e',icons:[{src:'data:image/svg+xml,'+encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><rect fill="#1a1a2e" width="100" height="100" rx="18"/><text x="50" y="68" font-size="52" text-anchor="middle" fill="white">âš¡</text></svg>'),sizes:'192x192',type:'image/svg+xml'}]};
        document.getElementById('pwa-manifest').setAttribute('href', URL.createObjectURL(new Blob([JSON.stringify(m)], {type:'application/json'})));
        if ('serviceWorker' in navigator) {
            var sw = "self.addEventListener('install',function(){self.skipWaiting()});self.addEventListener('activate',function(e){e.waitUntil(clients.claim())});self.addEventListener('fetch',function(e){e.respondWith(fetch(e.request).catch(function(){return caches.match(e.request)}))});";
            navigator.serviceWorker.register(URL.createObjectURL(new Blob([sw], {type:'application/javascript'}))).catch(function(){});
        }
    }

    // =================== INIT ===================

    function init() {
        initDB().then(function() {
            return loadCfg();
        }).then(function() {
            // Migrate old einkMode to new theme setting
            if (cfg.einkMode !== undefined && !cfg.theme) { cfg.theme = cfg.einkMode ? 'eink' : 'dark'; delete cfg.einkMode; }
            if (!cfg.theme) cfg.theme = 'midnight';
            applyTheme();
            applyFontScale();
            document.getElementById('timeFilterMain').value = cfg.timeFilter || 'week';
            setupPWA();
            return loadArticles();
        }).then(function() {
            if (articles.length === 0) {
                refresh();
            } else {
                updateStats();
                render();
            }
        }).catch(function(e) {
            console.error('Init error:', e);
            document.getElementById('content').innerHTML = '<div class="error">Failed to initialize. Please refresh the page.</div>';
        });
    }

    init();

    window.onclick = function(e) {
        if (e.target === document.getElementById('settingsModal')) closeSettings();
    };

    // Public API
    return {
        refresh: refresh,
        loadMore: loadMore,
        switchTab: switchTab,
        updateTimeFilter: updateTimeFilter,
        openSettings: openSettings,
        closeSettings: closeSettings,
        saveSettings: saveSettings,
        clearAll: clearAll,
        addRss: addRss,
        rmRss: rmRss,
        toggleCmt: toggleComments,
        installPWA: installPWA,
        cycleFont: cycleFont
    };

})();
</script>
</body>
</html>
